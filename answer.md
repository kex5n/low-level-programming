# ch01
問題2 フォンノイマンアーキテクチャの主な原則は？
問題3 レジスタとは？
問題4 ハードウェアスタックとは？
問題5 割り込みとは？
問題6 フォン・ノイマンのモデルの主な問題点で、現在の
問題7 Intel 64の主な汎用レジスタは？
問題8 スタックポインタの目的は？
問題9 スタックは空になるか？
問題10 スタック内の要素を数えられるか？

# ch02
問題11 排他的論理和を計算する演算で、同じ値同士でこの演算を行うことで全てのbitを0にして初期化している。
問題12 0 # https://blog.amedama.jp/entry/linux-system-call-assembler#NASM--x86-%E3%81%A7-exit2-%E3%82%92%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%99%E3%81%A0%E3%81%91%E3%81%AE%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0
問題13
問題14 ?
問題15 sar (shift arithmetic right) -> 算術右シフト, shr -> (shift logic right) -> 論理右シフト 符号を考慮するか否か。https://itmanabi.com/shift-operation/
問題16 0x使う?
問題17 同じ？ rflagレジスタのZFが1の時jumpする。
問題18 全て1になっている
問題19 r13を初期化していないところ？
問題23 eaxはraxの下位32bit, axはeaxの下位16bit, ahはaxの上位8bit, alは下位8bit
問題24 算術シフトした上でandを取る
問題25 レジスタの内容を退避させておく。push, pop
問題26 
- mov [rax], 0 サイズを指定していない
- mov r3b, al r3bは未定義
- mov r9w, r2d r2dは未定義
- mov mov rcx, [rax + rbx + rdx] 3つの和算は無理？
- mov [r8 + r7 + 10], 6 サイズを指定していない、r7が未定義？
- mov [r8 + r7 + 10], r6 r7が未定義？
問題27 呼び出し先退避レジスタ: rbx, rbp, rsp, r12-r15
問題28 呼び出し元退避レジスタ: 呼び出し先退避レジスタ以外
問題29 プログラムカウンタ
問題30 
問題31 直前に行った演算の結果が0であったか否か
問題32
- sar 算術右シフト
- shr 論理右シフト
- xor 排他的論理和
- jmp オペランドのアドレスに移動する。
- ja, jb 直前に行ったcmpの結果、ひとつ目のオペランドがふたつ目より大きかったか、小さかったか。
- cpm オペランド同士を比較する。
- mov レジスタに値を書き込む
- inc, dec インクリメント、デクリメント
- add オペランド同士を和算し、一つ目のオペランドに結果を格納する
- imul, mul オペランド同士を(符号なし/あり)乗算し、一つ目のオペランドに結果を格納する
- sub オペランド同士を減算し、一つ目のオペランドに結果を格納する
- idiv, div オペランド同士を(符号なし/あり)除算し、一つ目のオペランドに結果を格納する
- call, ret 関数呼び出し、復帰。callでripの値をスタックにプッシュし、retでripに戻す。
- push, pop スタックにオペランドの値を格納する/取り出す
問題33 アドレスの別名。サイズはなし
問題34 cmpを2回行う
問題35 前者は符号なし、後者は符号あり
問題36 同じ？
問題37 testコマンドを使う
問題38 プログラムが正常終了したかエラーで終了したか
問題39 
